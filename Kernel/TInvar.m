(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



xAct`TInvar`$xTensorVersionExpected = {"1.2.0", {2021, 10, 17}};
xAct`TInvar`$Version = {"0.4.0", {2024, 8, 14}};


With[{xAct`TInvar`Private`TInvarSymbols=DeleteCases[Join[Names["xAct`TInvar`*"],Names["xAct`TInvar`Private`*"]],"$Version"|"xAct`TInvar`$Version"|"$TInvarVersionExpected"|"xAct`TInvar`$xTensorVersionExpected"]},
  Unprotect /@ xAct`TInvar`Private`TInvarSymbols;
  Clear /@ xAct`TInvar`Private`TInvarSymbols;
]


If[Unevaluated[xAct`xCore`Private`$LastPackage]===xAct`xCore`Private`$LastPackage,
  xAct`xCore`Private`$LastPackage="xAct`TInvar`"];


BeginPackage["xAct`TInvar`", {"xAct`xTensor`", "xAct`xPerm`", "xAct`xCore`"}]


(* ::Input::Initialization:: *)
General::xTensorVersion="Loaded xTensor version `1` but expected version `2` at least.";
If[Not@OrderedQ@Map[Last,{$xTensorVersionExpected,xAct`xTensor`$Version}],Message[General::xTensorVersion,xAct`xTensor`$Version,$xTensorVersionExpected];
Abort[]]


Print[xAct`xCore`Private`bars];
Print["Package xAct`TInvar`  version ",$Version[[1]],", ",$Version[[2]]];
Print["Copyright (C) 2023, Kevin Kiely, Barry Wardell, Adrian Ottewill and Jose M. Martin-Garcia."];


(* ::Input::Initialization:: *)
Off[General::shdw]
xAct`TInvar`Disclaimer[]:=Print["These are points 11 and 12 of the General Public License:\n\nBECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM `AS IS\.b4 WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\nIN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES."]
On[General::shdw]


(* ::Input::Initialization:: *)
If[xAct`xCore`Private`$LastPackage==="xAct`TInvar`",
Unset[xAct`xCore`Private`$LastPackage];
Print[xAct`xCore`Private`bars];
Print["These packages come with ABSOLUTELY NO WARRANTY; for details type Disclaimer[]. This is free software, and you are welcome to redistribute it under certain conditions. See the General Public License for details."];
Print[xAct`xCore`Private`bars]]


(* FIXME: make this public as a hack - need to find a better solution*)
(*metric;*)


(* ::Input::Initialization:: *)
$TInvarDirectory::usage="$TInvarDirectory is a global variable giving the directory in which the package file and the database can be found.";


(* ::Input::Initialization:: *)
InvarCases::usage="InvarCases[s, d] returns the list of cases of order (number of metric derivatives) s and degree (number of Riemanns) d. InvarCases[s] returns the list of cases of order s. InvarCases[] returns the list of all cases handled by Invar (currently the 47 cases up to order 12 plus the algebraic case of degree 7).";
InvarDualCases::usage="InvarDualCases[s, d] returns the list of dual cases of order (number of metric derivatives) s and degree (number of Riemanns) d in dimension 4. InvarDualCases[s] returns the list of dual cases of order s. InvarDualCases[] returns the list of all dual cases handled by Invar (currently the 14 cases up to order 8 plus the algebraic case of degree 5).";


(* ::Input::Initialization:: *)
RInv::usage="RInv[g][c, r] denotes the Riemann invariant of case c and index r associated to the metric g.";
DualRInv::usage="DualRInv[g][c, r] denotes the dual Riemann invariant of case c and index r associated to the metric g.";
RPerm::usage="RPerm[g][{c, ed}, perm] denotes a Riemann invariant of case c with ed epsilon tensors (both associated to metric g), after reordering the indices from a canonical order using permutation perm.";


(* ::Input::Initialization:: *)
WInv::usage="WInv[g][c, r] denotes the Weyl invariant of case c and index r associated to the metric g.";
DualWInv::usage="DualWInv[g][c, r] denotes the dual Weyl invariant of case c and index r associated to the metric g.";
WPerm::usage="WPermRPerm[g][{Rd, ed}, perm] denotes a Weyl invariant  formed by Rd Weyl tensors and ed epsilon tensors, after reordering the indices from a canonical order using permutation perm. Contracted Weyls encode the Traceless Ricci tensor.";


(* ::Input::Initialization:: *)
RInvs::usage="RInvs[step, case] gives all independent Riemann invariants at the given step (1, 2, 3, 4, 5 or 6) and the given case. Using RInvs[g] instead of RInvs we get the particularization of the invariants to metric g.";
WInvs::usage="WInvs[step, case] gives all independent Weyl invariants at the given step (1, 2, 3, 4, 5, 6) and the given case. Using WInvs[g] instead of WInvs we get the particularization of the invariants to metric g.";
DualRInvs::usage="DualRInvs[step, case] gives all independent dual Riemann invariants at the given step (1, 2, 3, 4, 5 or 6) and the given case. Using DualRInvs[g] instead of RInvs we get the particularization of the dual invariants to metric g.";
DualWInvs::usage="DualWInvs[step, case] gives all independent dual Weyl invariants at the given step (1, 2, 3, 4, 5 or 6) and the given case. Using DualWInvs[g] instead of WInvs we get the particularization of the dual invariants to metric g.";
RInvRules::usage="RInvRules[step, case] gives the list of rules to be used to simplify Riemann non-dual invariants of the given case at the given step.";
WInvRules::usage="WInvRules[step, case] gives the list of rules to be used to simplify Weyl non-dual invariants of the given case at the given step.";
DualRInvRules::usage="DualRInvRules[step, case] gives the list of rules to be used to simplify Riemann dual invariants of the given case at the given step.";
DualWInvRules::usage="DualWInvRules[step, case] gives the list of rules to be used to simplify Weyl dual invariants of the given case at the given step.";


(* ::Input::Initialization:: *)
MaxIndex::usage="MaxIndex[step] gives the largest index of the non-dual invariants at the given step.";
MaxDualIndex::usage="MaxDualIndex[step] gives the largest index of the dual invariants at the given step.";


(* ::Input::Initialization:: *)
InvSimplify::usage="InvSimplify[expr, level] simplifies the invariants of the form inv[metric][case,count] in the expression expr, where inv is one of RInv, DualRInv, WInv, DualWInv. There are six possible levels of simplification: 1 means no simplification; 2 uses the cyclic identity; 3 uses the Bianchi identity; 4 commutes covariant derivatives; 5 uses dimensionally dependent (Lovelock type) identities and 6 reduces some non-dual invariants into products of dual invariants. The default level used in InvSimplify[expr] is $InvSimplifyLevel.";
InvToPerm::usage="InvToPerm[expr] converts all invariants in expr into their corresponding permutations with head RPerm or WPerm.";
PermToRiemann::usage="PermToRiemann[expr, cr] converts all permutations into their explicit tensor expressions. With cr=True contracted Riemann tensors are replaced by Ricci tensors. The default value used in PermToRiemann[expr] is $CurvatureRelations.";
InvToRiemann::usage="InvToRiemann[expr, cr] converts all invariants into their explicit tensor expressions. With cr=True contracted Riemann tensors are replaced by Ricci tensors. The default value used in InvToRiemann[expr] is $CurvatureRelations.";
RiemannToPerm::usage="RiemannToPerm[expr, g] converts all Riemann scalars of metric g into their canonical permutations. If g is a list of metrics then the command is folded over the list. RiemannToPerm[expr] is automatically converted into RiemannToPerm[expr, $Metrics].";
PermToInv::usage="PermToInv[expr] converts all permutations in expr into their correspondent invariants. It is assumed that the permutations have been already canonicalized.";
RiemannToInv::usage="RiemannToInv[expr, g] converts all Riemann scalars of metric g into their invariant form. If g is a list of metrics then the command is folded over the list. RiemannToInv[expr] is automatically converted into RiemannToInv[expr, $Metrics].";
RiemannSimplify::usage="RiemannSimplify[expr, level, cr, g] simplifies the Riemann scalars of metric g using relations up to the given level (see usage message for InvSimplify). With cr=True contracted Riemann tensors are replaced by Ricci tensors. If g is a list of metrics then the command is folded over the list. RiemannSimplify[expr] uses the defaults $InvSimplifyLevel, $CurvatureRelations and $Metrics, respectively. See usage messages for those global variables.";


(* ::Input::Initialization:: *)
dim::usage="dim is a constant symbol used in the Invar rules to denote the dimension of a manifold.";
sigma::usage="sigma is a constant symbol used in the Invar rules to denote the sign of the determinant of a metric.";


(* ::Input::Initialization:: *)
$InvSimplifyLevel::usage="$InvSimplifyLevel is a global variable specifying the default level of simplification in InvSimplify. Initially it is set to 6.";
$CurvatureRelations::usage="$CurvatureRelations is a global variable specifying the default behaviour of contracted Riemann conversion in the functions PermToRiemann, InvToRiemann and RiemannSimplify.";


Begin["`Private`"]


ReportSetOption[ContractMetric,AllowUpperDerivatives->True];


$InvSimplifyLevel=6;
$CurvatureRelations=False;


ReportSet[$PrePrint,ScreenDollarIndices];


ReportSet[$CovDFormat,"Postfix"];


ReportSetOption[DefCovD,CurvatureRelations->False];


tostring[list_List]:=StringJoin[ToString/@list];


(*Change made here to format RInv to have a super script with the rank and add a argument for indices. No duals in this version *)


RInv[metric_,IndexList[]][case_,index_]:=RInv[metric][0,case,index];
DualRInv[metric_,IndexList[]][case_,index_]:=DualRInv[metric][0,case,index];
WInv[metric_,IndexList[]][case_,index_]:=WInv[metric][0,case,index];
DualWInv[metric_,IndexList[]][case_,index_]:=DualWInv[metric][0,case,index];


RInv[case_List,index_?IntegerQ]:=RInv[0,case,index];
DualRInv[case_List,index_?IntegerQ]:=DualRInv[0,case,index];
WInv[case_List,index_?IntegerQ]:=WInv[0,case,index];
DualWInv[case_List,index_?IntegerQ]:=DualRInv[0,case,index];


Format[RInv[_,_][rank_,case_,index_]]:=Subscript[Superscript["I",ToString[rank]],StringJoin[tostring[case],"," , ToString[index]]]


Format[WInv[_,_][rank_,case_,index_]]:=Subscript[Superscript["W",ToString[rank]],StringJoin[tostring[case],"," , ToString[index]]]


Format[DualRInv[_,_][rank_,case_,index_]]:=Subscript[Superscript["D",ToString[rank]],StringJoin[tostring[case],"," , ToString[index]]]


Format[DualWInv[_,_][rank_,case_,index_]]:=Subscript[Superscript["X",ToString[rank]],StringJoin[tostring[case],"," , ToString[index]]]


Format[RInv[rank_,case_,index_]]:=Subscript[Superscript["I",ToString[rank]],StringJoin[tostring[case],"," , ToString[index]]]


Format[DualRInv[rank_,case_,index_]]:=Subscript[Superscript["D",ToString[rank]],StringJoin[tostring[case],"," , ToString[index]]]


Format[WInv[rank_,case_,index_]]:=Subscript[Superscript["W",ToString[rank]],StringJoin[tostring[case],"," , ToString[index]]]


Format[DualWInv[rank_,case_,index_]]:=Subscript[Superscript["X",ToString[rank]],StringJoin[tostring[case],"," , ToString[index]]]


$ReadWeyl=False;


$TInvarDirectory=ParentDirectory[DirectoryName[$InputFileName]];


$DataBaseDir="Riemann/";


(*Need to add the backwards compatibility notation*)


(*From Riemann to Weyl. No Dimension added*)


WInvs[step_Integer,rank_,deg_]:=RInvs[step,rank,deg]/.RInv->WInv;


(*No change from Invar*)


SetAttributes[ProtSet,HoldFirst];
ProtSet[head_[args___],value_]:=Module[{prot=Unprotect[head]},Set[head[args],value];Protect[Evaluate[prot]];value];


(*Same as Invar*)


intercase[case_List]:=StringJoin@Insert[ToString/@case,"_",List/@Range[2,Length[case]]];


(*No Dim also modified for rank-case-step *)


filename[step_,rank_,case_]:=StringJoin["RInv-",ToString[rank],"-",intercase[case],"-",ToString[step]];


filename[step:(5|6),rank_,case_,dim_]:=filename[ToString[step],rank,case]<>"_"<>ToString[dim];


dualfilename[5,rank_,case_,dim_]:=dualfilename["5",rank,case]<>"_"<>ToString[dim];
dualfilename[step_,rank_,case_]:=StringJoin["DInv-",ToString[rank],"-",intercase[case],"-",ToString[step]];


(*No changes*)


RInv::nodatabase="Can't find the Invar database. You can download it from http://www.xact.es/Invar/.";
CheckImport[args__]:=Quiet[Check[Import[args],Message[RInv::nodatabase];Abort[]],Import::nffil];


(*All permutations are in Mathematica notation*)


firstof[{}]:=0;
firstof[{{a_,b_}}]:=a;
firstof[{{a_,b_},__}]:=a;


positionof[string_String,substring_String]:=firstof@StringPosition[string,substring];
movetofirst[0]:=1;
movetofirst[x_]:=x+4;


replacebrackets[string_String]:=StringReplace[string,{"["->"{","]"->"}"}]
replaceequal[string_String]:=StringReplace[string,{"="->"->"}]


readline[string_]:=StringTake[string,{movetofirst@positionof[string," := "],StringLength[string]-1}]


(*Need to check this works for TInvar*)


ReadInvarPerms[filename_,"Maple"]:=ToExpression/@replacebrackets/@readline/@CheckImport[FileNameJoin[{$TInvarDirectory,filename<>".gz"}],"Lines"];


ReadInvarRules[filename_,"Mathematica"]:=ToExpression/@CheckImport[FileNameJoin[{$TInvarDirectory,filename<>".gz"}],"Lines"];


RemoveRInvRules[step_Integer,rank_Integer,degree_Integer,dim___]:=RemoveRInvRules[step,rank,Table[0,{degree}]];
RemoveRInvRules[step_Integer,rank_Integer,case_List,dim___]:=(
Unset[DispatchRules[RInv,step,rank, case,dim]];
Unprotect[RInvRules];
Unset[RInvRules[step,rank,case,dim]];
Protect[RInvRules];
);

RemoveDualRInvRules[step_Integer,rank_Integer,degree_Integer,dim___]:=RemoveDualRInvRules[step,rank,Table[0,{degree}]];
RemoveDualRInvRules[step_Integer,rank_Integer,case_List,dim___]:=(
Unset[DispatchRules[DualRInv,step,rank, case,dim]];
Unprotect[DualRInvRules];
Unset[DualRInvRules[step,rank,case,dim]];
Protect[DualRInvRules];
);


(*Need to test this. No changes made*)


addRdep[Rule[inv_[case_ ,count_],rhs_]]:=Rule[inv[metric_ ,indexlist_][case,count],rhs/.{RInv->RInv[metric],DualRInv->DualRInv[metric],WInv->WInv[metric],DualWInv->DualWInv[metric]}]


RInvs[metric_,indexlist_IndexList][args__]:=RInvs[args]/.RInv->RInv[metric];WInvs[metric_,indexlist_IndexList][args__]:=WInvs[args]/.WInv->WInv[metric];


DualRInvs[metric_][args__]:=DualRInvs[args]/.DualRInv->DualRInv[metric];
DualWInvs[metric_][args__]:=DualWInvs[args]/.DualWInv->DualWInv[metric];


$DefaultDim:=DimOfVBundle@VBundleOfMetric@First@$Metrics;


(*With the way this is currently implimented it is not very clear as the cases will depend on the rank. Should I impliment a InvarCases[rank_, order_,deg_]?*)


InvarCases[0]:=Flatten[Table[InvarCases[0,order],{order,2,14,2}],1];
InvarCases[1]:=Flatten[Table[InvarCases[1,order],{order,3,6,2}],1];
InvarCases[2]:=Flatten[Table[InvarCases[2,order],{order,2,6,2}],1];
InvarCases[3]:=Flatten[Table[InvarCases[3,order],{order,3,6,2}],1];
InvarCases[4]:=Flatten[Table[InvarCases[4,order],{order,2,6,2}],1];
InvarCases[5]:=Flatten[Table[InvarCases[5,order],{order,3,6,2}],1];
InvarCases[6]:=Flatten[Table[InvarCases[6,order],{order,4,6,2}],1];
InvarCases[7]:=Flatten[Table[InvarCases[7,order],{order,5,6,2}],1];
InvarCases[8]:=Flatten[Table[InvarCases[8,order],{order,4,6,2}],1];
InvarCases[9]:=Flatten[Table[InvarCases[9,order],{order,5,6,2}],1];
InvarCases[10]:=Flatten[Table[InvarCases[10,order],{order,6,6,2}],1];
InvarCases[12]:=Flatten[Table[InvarCases[12,order],{order,6,6,2}],1];

InvarCases[rank_,order_Integer?EvenQ]:=InvarCases[rank,order,Reverse@Range[order/2]];
InvarCases[rank_,order_Integer?EvenQ,list_List]:=Flatten[InvarCases[rank,order,#]&/@list,1];
InvarCases[rank_,order_Integer?OddQ]:=InvarCases[rank,order,Reverse@Range[Round[(order-1)/2]]];

InvarCases[rank_,order_Integer?OddQ,list_List]:=Flatten[InvarCases[rank,order,#]&/@list,1];

InvarCases[0,2,1]={{0}};

InvarCases[0,4,1]={{2}};
InvarCases[0,4,2]={{0,0}};

InvarCases[0,6,1]={{4}};
InvarCases[0,6,2]={{0,2},{1,1}};
InvarCases[0,6,3]={{0,0,0}};

InvarCases[0,8,1]={{6}};
InvarCases[0,8,2]={{0,4},{1,3},{2,2}};
InvarCases[0,8,3]={{0,0,2},{0,1,1}};
InvarCases[0,8,4]={{0,0,0,0}};

InvarCases[0,10,1]={{8}};
InvarCases[0,10,2]={{0,6},{1,5},{2,4},{3,3}};
InvarCases[0,10,3]={{0,0,4},{0,1,3},{0,2,2},{1,1,2}};
InvarCases[0,10,4]={{0,0,0,2},{0,0,1,1}};
InvarCases[0,10,5]={{0,0,0,0,0}};

InvarCases[0,12,1]={{10}};
InvarCases[0,12,2]={{0,8},{1,7},{2,6},{3,5},{4,4}};
InvarCases[0,12,3]={{0,0,6},{0,1,5},{0,2,4},{1,1,4},{0,3,3},{1,2,3},{2,2,2}};
InvarCases[0,12,4]={{0,0,0,4},{0,0,1,3},{0,0,2,2},{0,1,1,2},{1,1,1,1}};
InvarCases[0,12,5]={{0,0,0,0,2},{0,0,0,1,1}};
InvarCases[0,12,6]={{0,0,0,0,0,0}};

InvarCases[0,14,7]={{0,0,0,0,0,0,0}};


InvarCases[2,2,1]={{0}};

InvarCases[4,2,1]={{0}};

InvarCases[1,3,1]={{1}};
InvarCases[3,3,1]={{1}};
InvarCases[5,3,1]={{1}};

InvarCases[2,4,1]={{2}};
InvarCases[4,4,1]={{2}};
InvarCases[6,4,1]={{2}};

InvarCases[8,4,2]={{0,0}};
InvarCases[6,4,2]={{0,0}};
InvarCases[4,4,2]={{0,0}};
InvarCases[2,4,2]={{0,0}};

InvarCases[7,5,1]={{3}};
InvarCases[5,5,1]={{3}};
InvarCases[3,5,1]={{3}};
InvarCases[1,5,1]={{3}};

InvarCases[9,5,2]={{0,1}};
InvarCases[7,5,2]={{0,1}};
InvarCases[5,5,2]={{0,1}};
InvarCases[3,5,2]={{0,1}};
InvarCases[1,5,2]={{0,1}};

InvarCases[8,6,1]={{4}};
InvarCases[6,6,1]={{4}};
InvarCases[4,6,1]={{4}};
InvarCases[2,6,1]={{4}};

InvarCases[10,6,2]={{0,2},{1,1}};
InvarCases[8,6,2]={{0,2},{1,1}};
InvarCases[6,6,2]={{0,2},{1,1}};
InvarCases[4,6,2]={{0,2},{1,1}};
InvarCases[2,6,2]={{0,2},{1,1}};

InvarCases[12,6,3]={{0,0,0}};
InvarCases[10,6,3]={{0,0,0}};
InvarCases[8,6,3]={{0,0,0}};
InvarCases[6,6,3]={{0,0,0}};
InvarCases[4,6,3]={{0,0,0}};
InvarCases[2,6,3]={{0,0,0}};

InvarCases[0,14]:=InvarCases[0,14,7];

InvarCases[0,2,1]={{0}};

InvarCases[0,4,1]={{2}};
InvarCases[0,4,2]={{0,0}};

InvarCases[0,6,1]={{4}};
InvarCases[0,6,2]={{0,2},{1,1}};
InvarCases[0,6,3]={{0,0,0}};

InvarCases[0,8,1]={{6}};
InvarCases[0,8,2]={{0,4},{1,3},{2,2}};
InvarCases[0,8,3]={{0,0,2},{0,1,1}};
InvarCases[0,8,4]={{0,0,0,0}};

InvarCases[0,10,1]={{8}};
InvarCases[0,10,2]={{0,6},{1,5},{2,4},{3,3}};
InvarCases[0,10,3]={{0,0,4},{0,1,3},{0,2,2},{1,1,2}};
InvarCases[0,10,4]={{0,0,0,2},{0,0,1,1}};
InvarCases[0,10,5]={{0,0,0,0,0}};

InvarCases[0,12,1]={{10}};
InvarCases[0,12,2]={{0,8},{1,7},{2,6},{3,5},{4,4}};
InvarCases[0,12,3]={{0,0,6},{0,1,5},{0,2,4},{1,1,4},{0,3,3},{1,2,3},{2,2,2}};
InvarCases[0,12,4]={{0,0,0,4},{0,0,1,3},{0,0,2,2},{0,1,1,2},{1,1,1,1}};
InvarCases[0,12,5]={{0,0,0,0,2},{0,0,0,1,1}};
InvarCases[0,12,6]={{0,0,0,0,0,0}};

InvarCases[0,14,7]={{0,0,0,0,0,0,0}};


InvarDualCases[0]:=Flatten[Table[InvarDualCases[0,order],{order,2,10,2}],1];
InvarDualCases[0,order_Integer?EvenQ]:=InvarDualCases[0,order,Reverse@Range[order/2]];
InvarDualCases[0,order_Integer?EvenQ,list_List]:=Flatten[InvarDualCases[0,order,#]&/@list,1];

InvarDualCases[0,10]:=InvarDualCases[0,10,5];

InvarDualCases[0,2,1]={{0}};

InvarDualCases[0,4,1]={{2}};
InvarDualCases[0,4,2]={{0,0}};

InvarDualCases[0,6,1]={{4}};
InvarDualCases[0,6,2]={{0,2},{1,1}};
InvarDualCases[0,6,3]={{0,0,0}};

InvarDualCases[0,8,1]={{6}};
InvarDualCases[0,8,2]={{0,4},{1,3},{2,2}};
InvarDualCases[0,8,3]={{0,0,2},{0,1,1}};
InvarDualCases[0,8,4]={{0,0,0,0}};

InvarDualCases[0,10,5]={{0,0,0,0,0}};

InvarDualCases[x_]:=Throw[Print["Invalid order ",x]];
InvarDualCases[args__]:=Throw[Print["Invar cannot work with the dual cases ",{args}]];


MaxIndex[0,{}]:=0;

MaxIndex[0,{0}]:=1;

MaxIndex[0,{0,0}]:=3;
MaxIndex[0,{2}]:=2;

MaxIndex[0,{0,0,0}]:=9;
MaxIndex[0,{0,2}]:=12;
MaxIndex[0,{1,1}]:=12;
MaxIndex[0,{4}]:=12;

MaxIndex[0,{0,0,0,0}]:=38;
MaxIndex[0,{0,0,2}]:=99;
MaxIndex[0,{0,1,1}]:=125;
MaxIndex[0,{0,4}]:=126;
MaxIndex[0,{1,3}]:=138;
MaxIndex[0,{2,2}]:=86;
MaxIndex[0,{6}]:=105;

MaxIndex[0,{0,0,0,0,0}]:=204;
MaxIndex[0,{0,0,0,2}]:=1020;
MaxIndex[0,{0,0,1,1}]:=1749;
MaxIndex[0,{0,0,4}]:=1473;
MaxIndex[0,{0,1,3}]:=3099;
MaxIndex[0,{0,2,2}]:=1622;
MaxIndex[0,{1,1,2}]:=1617;
MaxIndex[0,{0,6}]:=1665;
MaxIndex[0,{1,5}]:=1770;
MaxIndex[0,{2,4}]:=1746;
MaxIndex[0,{3,3}]:=962;
MaxIndex[0,{8}]:=1155;

MaxIndex[0,{0,0,0,0,0,0}]:=1613;
MaxIndex[0,{0,0,0,0,2}]:=12722;
MaxIndex[0,{0,0,0,1,1}]:=27022;
MaxIndex[0,{0,0,0,4}]:=19617;
MaxIndex[0,{0,0,1,3}]:=60984;
MaxIndex[0,{0,0,2,2}]:=30974;
MaxIndex[0,{0,1,1,2}]:=62465;
MaxIndex[0,{1,1,1,1}]:=5606;
MaxIndex[0,{0,0,6}]:=25590;
MaxIndex[0,{0,1,5}]:=53160;
MaxIndex[0,{0,2,4}]:=52764;
MaxIndex[0,{1,1,4}]:=27396;
MaxIndex[0,{0,3,3}]:=27024;
MaxIndex[0,{1,2,3}]:=54654;
MaxIndex[0,{2,2,2}]:=9104;
MaxIndex[0,{0,8}]:=25515;
MaxIndex[0,{1,7}]:=26670;
MaxIndex[0,{2,6}]:=26460;
MaxIndex[0,{3,5}]:=26670;
MaxIndex[0,{4,4}]:=13607;
MaxIndex[0,{10}]:=15120;

MaxIndex[0,{0,0,0,0,0,0,0}]:=16532;

MaxIndex[0,{0,0,0,0,0,0,0,0}]:=217395;

MaxIndex[0,{0,0,0,0,0,0,0,0,0}]:=3406747;


MaxIndex[2,{0}]=1;

MaxIndex[4,{0}]=3;

MaxIndex[5,{1}]=15;
MaxIndex[3,{1}]=6;
MaxIndex[1,{1}]=2;

MaxIndex[6,{2}]=90;
MaxIndex[4,{2}]=39;
MaxIndex[2,{2}]=9;

MaxIndex[8,{0,0}]=315;
MaxIndex[6,{0,0}]=135;
MaxIndex[4,{0,0}]=33;
MaxIndex[2,{0,0}]=5;

MaxIndex[7,{3}]=630;
MaxIndex[5,{3}]=285;
MaxIndex[3,{3}]=66;
MaxIndex[1,{3}]=11;

MaxIndex[9,{0,1}]=5670;
MaxIndex[7,{0,1}]=2520;
MaxIndex[5,{0,1}]=600;
MaxIndex[3,{0,1}]=96;
MaxIndex[1,{0,1}]=14;

MaxIndex[8,{4}]=5040;
MaxIndex[6,{4}]=2340;
MaxIndex[4,{4}]=549;
MaxIndex[2,{4}]=86;

MaxIndex[10,{1,1}]=28350;
MaxIndex[8,{1,1}]=12915;
MaxIndex[6,{1,1}]=3060;
MaxIndex[4,{1,1}]=492;
MaxIndex[2,{1,1}]=62;

MaxIndex[10,{0,2}]=56700;
MaxIndex[8,{0,2}]=25830;
MaxIndex[6,{0,2}]=6075;
MaxIndex[4,{0,2}]=966;
MaxIndex[2,{0,2}]=119;

MaxIndex[12,{0,0,0}]=155925;
MaxIndex[10,{0,0,0}]=70875;
MaxIndex[8,{0,0,0}]=16695;
MaxIndex[6,{0,0,0}]=2670;
MaxIndex[4,{0,0,0}]=336;
MaxIndex[2,{0,0,0}]=33;


MaxDualIndex[0,{}]=0;

MaxDualIndex[0,{0}]=1;

MaxDualIndex[0,{0,0}]=4;
MaxDualIndex[0,{2}]=3;

MaxDualIndex[0,{0,0,0}]=27;
MaxDualIndex[0,{0,2}]=58;
MaxDualIndex[0,{1,1}]=36;
MaxDualIndex[0,{4}]=32;

MaxDualIndex[0,{0,0,0,0}]=232;
MaxDualIndex[0,{0,0,2}]=967;
MaxDualIndex[0,{0,1,1}]=1047;
MaxDualIndex[0,{0,4}]=876;
MaxDualIndex[0,{1,3}]=920;
MaxDualIndex[0,{2,2}]=478;
MaxDualIndex[0,{6}]=435;

MaxDualIndex[0,{0,0,0,0,0}]=2582;

MaxDualIndex[0,{0,0,0,0,0,0}]=35090;

MaxDualIndex[0,{0,0,0,0,0,0,0}]=558323;

MaxDualIndex[rank_,case_]:=Throw[Print["Dual case", case," and rank",rank," not included."]];


(* Added rank argument*)


RInvs[1,rank_,case_List]:=ProtSet[RInvs[1,rank,case],Map[RInv[rank,case,#]&,Range[MaxIndex[rank,case]]]];


DualRInvs[1,rank_,case_List]:=ProtSet[DualRInvs[1,rank,case],Map[DualRInv[rank,case,#]&,Range[MaxDualIndex[rank,case]]]];


WInvs[1,rank_,case_List]:=ProtSet[WInvs[1,rank,case],Map[WInv[rank,case,#]&,Range[MaxIndex[rank,case]]]];


DualWInvs[1,rank_,case_List]:=ProtSet[WInvs[1,rank,case],Map[WInv[rank,case,#]&,Range[MaxIndex[rank,case]]]];


(*No dim added free*)


DispatchRules[RInv,step_,rank_,case_,dim___]:=Block[{sigma},DispatchRules[RInv,step,rank,case,dim]=Dispatch[RInvRules[step,rank,case,dim]]];


DispatchRules[DualRInv,step_,rank_,case_,dim___]:=Block[{sigma},DispatchRules[DualRInv,step,rank,case,dim]=Dispatch[DualRInvRules[step,rank,case,dim]]];


DispatchRules[WInv,step_,rank_,case_,dim___]:=Block[{sigma},DispatchRules[WInv,step,rank,case,dim]=Dispatch[WInvRules[step,rank,case,dim]]];


DispatchRules[DualWInv,step_,rank_,case_,dim___]:=Block[{sigma},DispatchRules[DualWInv,step,rank,case,dim]=Dispatch[DualWInvRules[step,rank,case,dim]]];


RInvRules[1,rank_,case_List]:=Module[{result},
MaxIndex[case];
Print["Reading InvRules for step 1, rank ",rank ," and case ",case];result=Inner[Rule,tmphead@@RInvs[1,rank,case],tmphead@@ReadInvarPerms[$DataBaseDir<>"1/"<>filename[1,rank,case],"Maple"],List];
ProtSet[RInvRules[1,rank,case],result]
];


DualRInvRules[1,rank_,case_List]:=Module[{result},
MaxIndex[case];
Print["Reading DualInvRules for step 1, rank ",rank ," and case  ",case];result=Inner[Rule,tmphead@@DualRInvs[1,rank,case],tmphead@@ReadInvarPerms[$DataBaseDir<>"1/"<>dualfilename[1,rank,case],"Maple"],List];
ProtSet[DualRInvRules[1,rank,case],result]
];


reversecycles[inv_->{cycles__}]:=Cycles[cycles]->inv;
reversecycles[inv_->{}]:=Cycles[{}]->inv;


DispatchRInvToPermRules[rank_,case_List]:=DispatchRInvToPermRules[rank,case]=Dispatch[RInvRules[1,rank,case]];


DispatchPermToRInvRules[rank_,case_List]:=DispatchPermToRInvRules[rank,case]=Dispatch[reversecycles/@RInvRules[1,rank,case]];


DispatchDualRInvToPermRules[rank_,case_List]:=DispatchDualRInvToPermRules[rank,case]=Dispatch[DualRInvRules[1,rank,case]];


DispatchPermToDualRInvRules[rank_,case_List]:=DispatchPermToDualRInvRules[rank,case]=Dispatch[reversecycles/@DualRInvRules[1,rank,case]];


WInvRules[1,rank_,case_]:=RInvRules[1,rank,case]/.RInv->WInv;
DualWInvRules[1,rank_,case_]:=DualRInvRules[1,rank,case]/.DualRInv->DualWInv;


(*Examples with invariants*)


(*Add in the rest of the rules later*)


RInvs[2,rank_,case_]:=ProtSet[RInvs[2,rank,case],Complement[RInvs[1,rank,case],First/@RInvRules[2,rank,case]]];
DualRInvs[2,rank_,case_]:=ProtSet[DualRInvs[2,rank,case],Complement[DualRInvs[1,rank,case],First/@DualRInvRules[2,rank,case]]];


RInvRules[2,rank_,case_List]:=Module[{result},
MaxIndex[rank,case];
Print["Reading InvRules for step 2, rank ",rank," and case ",case];
result=ReadInvarRules[$DataBaseDir<>"2/"<>filename[2,rank,case],"Mathematica"];
ProtSet[RInvRules[2,rank,case],result]
];


DualRInvRules[2,rank_,case_List]:=Module[{result},
MaxDualIndex[rank,case];
Print["Reading DualInvRules for step 2, rank ",rank," and case ",case];
result=ReadInvarRules[$DataBaseDir<>"2/"<>dualfilename[2,rank,case],"Mathematica"];
ProtSet[DualRInvRules[2,rank,case],result]
];


WInvRules[2,rank_,case_]:=RInvRules[2,rank,case]/.RInv->WInv;
DualWInvRules[2,rank_,case_]:=DualRInvRules[2,rank,case]/.DualRInv->DualWInv;


RInvs[3,rank_,case_]:=ProtSet[RInvs[3,rank,case],Complement[RInvs[2,rank,case],First/@RInvRules[3,rank,case]]];
DualRInvs[3,rank_,case_]:=ProtSet[DualRInvs[3,rank,case],Complement[DualRInvs[2,rank,case],First/@DualRInvRules[3,rank,case]]];


RInvRules[3,rank_,case_List]:=Module[{result},
MaxIndex[rank,case];
Print["Reading InvRules for step 3, rank ",rank," and case ",case];
result=ReadInvarRules[$DataBaseDir<>"3/"<>filename[3,rank,case],"Mathematica"];
ProtSet[RInvRules[3,rank,case],result]
];


DualRInvRules[3,rank_,case_List]:=Module[{result},
MaxDualIndex[rank,case];
Print["Reading DualInvRules for step 3, rank ",rank," and case ",case];
result=ReadInvarRules[$DataBaseDir<>"3/"<>dualfilename[3,rank,case],"Mathematica"];
ProtSet[DualRInvRules[3,rank,case],result]
];


WInvRules[3,rank_,case_]:=RInvRules[3,rank,case]/.RInv->WInv;
DualWInvRules[3,rank_,case_]:=DualRInvRules[3,rank,case]/.DualRInv->DualWInv;


RInvs[4,rank_,case_]:=ProtSet[RInvs[4,rank,case],Complement[RInvs[3,rank,case],First/@RInvRules[4,rank,case]]];
DualRInvs[4,rank_,case_]:=ProtSet[DualRInvs[4,rank,case],Complement[DualRInvs[3,rank,case],First/@DualRInvRules[4,rank,case]]];


$ExpandedCommuteOrder12Q=False;


extendedQ[case_]:=$ExpandedCommuteOrder12Q/;MemberQ[InvarCases[0,12,{1,2,3}],case];
extendedQ[case_]:=True;


RInvRules[4,rank_,case_List]:=Module[{result,eQ=If[extendedQ[case],"","NE"]},
MaxIndex[case];
Print["Reading "<>eQ<>"InvRules for step 4, rank ",rank," and case ",case];
result=ReadInvarRules[$DataBaseDir<>"4/"<>filename[4,rank,case]<>eQ,"Mathematica"];
ProtSet[RInvRules[4,rank,case],result]
];
DualRInvRules[4,rank_,case_List]:=Module[{result},
MaxDualIndex[rank,case];
Print["Reading DualInvRules for step 4, rank ",rank," and case ",case];
result=ReadInvarRules[$DataBaseDir<>"4/"<>dualfilename[4,rank,case],"Mathematica"];
ProtSet[DualRInvRules[4,rank,case],result]
];


WInvRules[4,rank_,case_]:=RInvRules[4,rank,case]/.RInv->WInv;
DualWInvRules[4,rank_,case_]:=DualRInvRules[4,rank,case]/.DualRInv->DualWInv;


RInvs[5,rank_,case_]:=ProtSet[RInvs[5,rank,case],Complement[RInvs[4,rank,case],First/@RInvRules[5,rank,case]]];


RInvs[5,rank_,case_]:=RInvs[5,rank,case,$DefaultDim];
RInvs[5,rank_,case_,dim_]:=ProtSet[RInvs[5,rank,case,dim],Complement[RInvs[4,rank,case],First/@RInvRules[5,rank,case,dim]]];
DualRInvs[5,rank_,case_]:=DualRInvs[5,rank,case,$DefaultDim];
DualRInvs[5,rank_,case_,dim_]:=ProtSet[DualRInvs[5,rank, case,dim],Complement[DualRInvs[4,rank,case],First/@DualRInvRules[5,rank,case,dim]]];


RInvRules[5,rank_,case_List]:=RInvRules[5,rank,case,$DefaultDim];
RInvRules[5,rank_,case_List,dim_]:=Module[{result},
MaxIndex[rank,case];
If[rank>0,result={}; ,
Print["Reading InvRules for step 5, rank ",rank,", case "  ,case,  " and dimension ",dim];
result=ReadInvarRules[$DataBaseDir<>"5_"<>ToString[dim]<>"/"<>filename[5,rank,case,dim],"Mathematica"]];
ProtSet[RInvRules[5,rank,case,dim],result]
];


DualRInvRules[5,rank_,case_List]:=DualRInvRules[5,rank,case,$DefaultDim];
DualRInvRules[5,rank_,case_List,dim_]:=Module[{result},
MaxDualIndex[rank,case];
If[rank>0,result={};,
Print["Reading DualInvRules for step 5, rank ",rank," and case ",case];
result=ReadInvarRules[$DataBaseDir<>"5_"<>ToString[dim]<>"/"<>dualfilename[5,rank,case,dim],"Mathematica"]];
ProtSet[DualRInvRules[5,rank,case,dim],result]
];


WInvRules[5,0,case_,dim_]:=RInvRules[5,0,case,dim]/.RInv->WInv;
DualWInvRules[5,0,case_,dim_]:=DualRInvRules[5,0,case,dim]/.DualRInv->DualWInv;


RInvs[6,rank_,case_]:=RInvs[6,rank,case,$DefaultDim];
RInvs[6,rank_,case_,dim_]:=ProtSet[RInvs[6,rank,case,dim],Complement[RInvs[5,rank,case,dim],First/@RInvRules[6,rank,case,dim]]];
DualRInvs[6,rank_,case_]:=DualRInvs[6,rank,case,$DefaultDim];
DualRInvs[6,rank_,case_,dim_]:=ProtSet[DualRInvs[6,rank,case,dim],DualRInvs[5,rank,case,dim]];


RInvRules[6,rank_,case_List]:=RInvRules[6,rank,case,$DefaultDim];
RInvRules[6,rank_,case_List,dim_]:=Block[{sigma},
Module[{result},
MaxIndex[rank,case];
If[rank>0,result={};,
Print["Reading InvRules for step 6, rank ",rank,", case ",case," and dimension ",dim];
result=ReadInvarRules[$DataBaseDir<>"6_"<>ToString[dim]<>"/"<>filename[6,rank,case,dim],"Mathematica"]];
ProtSet[RInvRules[6,rank,case,dim],result]
]];


WInvRules[6,0,case_,dim_]:=RInvRules[6,0,case,dim]/.RInv->WInv;
DualWInvRules[6,0,case_,dim_]:=DualRInvRules[6,0,case,dim]/.DualRInv->DualWInv;


InvSimplify[expr_]:=InvSimplify[expr,$InvSimplifyLevel];
InvSimplify[expr_,1]:=expr;


InvSimplify[expr_,step_]:=Expand[expr/.{inv:(RInv|DualRInv|WInv|DualWInv)[metric_,Inds_IndexList][rank_,_,_]:>Block[{dim=DimOfVBundle@VBundleOfMetric@metric,sigma=SignDetOfMetric[metric],inds=Inds},InvSimplify1[inv,step,dim]] }];
SetNumberOfArguments[InvSimplify,{1,2}];


InvSimplify1[inv_,1,_]:=inv;
InvSimplify1[(DualRInv|DualWInv)[_,_][_,_,_],_,dim_Integer]:=Print["Duals are only handled in dimension 4."]/;dim=!=4;
InvSimplify1[_,5|6,dim_Integer]:=Print["Levels 5 and 6 of simplication are only possible in dimension 4."]/;dim=!=4;
InvSimplify1[inv:_[metric_,inds_IndexList][_,_,_],step:(2|3|4|5|6),_]:=Expand[InvSimplify56[InvSimplify234[inv,step],step]/.{RInv->RInv[metric,inds],DualRInv->DualRInv[metric,inds],WInv->WInv[metric,inds],DualWInv->DualWInv[metric,inds]}];
InvSimplify1[inv_,step_,dim_]:=Print["Invalid level of simplification: ",step];


InvSimplify234[RInv[metric_,indexlist_IndexList][rank_,case_,count_],step_]:=Module[{inds=indexlist,newexpr=RInv[rank,case,count]},
If[FreeQ[RInvs[ step,rank,case],newexpr],
newexpr=newexpr/.DispatchRules[RInv,2,rank,case];
newexpr=If[step>=3,newexpr/.DispatchRules[RInv,3,rank,case],newexpr];
newexpr=If[step>=4,newexpr/.DispatchRules[RInv,4,rank,case],newexpr]];
newexpr
];

InvSimplify234[DualRInv[metric_,indexlist_IndexList][rank_,case_,count_],step_]:=Module[{inds=indexlist,newexpr=DualRInv[rank,case,count]},
If[FreeQ[DualRInvs[ step,rank,case],newexpr],
newexpr=newexpr/.DispatchRules[DualRInv,2,rank,case];
newexpr=If[step>=3,newexpr/.DispatchRules[DualRInv,3,rank,case],newexpr];
newexpr=If[step>=4,newexpr/.DispatchRules[DualRInv,4,rank,case],newexpr]];
newexpr
];

InvSimplify234[WInv[metric_,indexlist_IndexList][rank_,case_,count_],step_]:=
If[MemberQ[RInvs[ step,rank,case],RInv[rank,case,count]],WInv[rank,case,count],
Module[{newexpr=RInv[rank,case,count]/.DispatchRules[RInv,2,rank,case]/.RInv->WInv},
newexpr=If[step>=3,newexpr/.DispatchRules[WInv,3,rank,case],newexpr];
newexpr=If[step>=4,newexpr/.DispatchRules[WInv,4,rank,case],newexpr];
newexpr]
];

InvSimplify234[DualWInv[metric_,indexlist_IndexList][rank_,case_,count_],step_]:=
If[MemberQ[DualRInvs[ step,rank,case],DualRInv[rank,case,count]],DualWInv[rank,case,count],
Module[{newexpr=DualRInv[rank,case,count]/.DispatchRules[DualRInv,2,rank,case]/.DualRInv->DualWInv},
newexpr=If[step>=3,newexpr/.DispatchRules[DualWInv,3,rank,case],newexpr];
newexpr=If[step>=4,newexpr/.DispatchRules[DualWInv,4,rank,case],newexpr];
newexpr]
];


RulesFor[inv_[0,case_,_],step_]:=DispatchRules[inv,step,0,case,dim]


InvSimplify56[expr_,step_/;step<5]:=expr;


(*Have not implimented dimension dependent rules for Tensors*)


InvSimplify56[expr_,5]:=expr/.{inv:(RInv|DualRInv|WInv|DualWInv)[0,case_,_]:>(inv/.RulesFor[inv,5])};


InvSimplify56[expr_,6]:=InvSimplify56[expr,5]/.{inv:(RInv|WInv)[0,case_,_]:>(inv/.RulesFor[inv,6])};


InvSimplify56[expr_,step_]:=expr;


toCycles[cycles:{___List}]:=Apply[Cycles,cycles];


InvToPerm[expr_]:=expr/.inv:(RInv|WInv)[_,_][_,_,_]:>InvToPerm[inv];


InvToPerm[-info___]:=-InvToPerm[info]


(*Commuting derivatives can introduce new contractions in the Riemann terms. Need to add dummy indices when this happens*)


InvToPerm[RInv[metric_,inds_IndexList][rank_,case_,count_]]:=RPerm[metric][{case,0},{rank},inds,toCycles[RInv[rank,case,count]/.DispatchRInvToPermRules[rank,case]]];


InvToPerm[WInv[metric_,inds_IndexList][rank_,case_,count_]]:=WPerm[metric][{case,0},{rank},inds,toCycles[RInv[rank,case,count]/.DispatchRInvToPermRules[rank,case]]]


InvToPerm[DualRInv[metric_,inds_IndexList][rank_,case_,count_]]:=RPerm[metric][{case,1},{rank},inds,toCycles[DualRInv[rank,case,count]/.DispatchDualRInvToPermRules[rank,case]]];


InvToPerm[DualWInv[metric_,inds_IndexList][rank_,case_,count_]]:=WPerm[metric][{case,1},{rank},inds,toCycles[DualRInv[rank,case,count]/.DispatchDualRInvToPermRules[rank,case]]];


SetNumberOfArguments[InvToPerm,1];


(*InvToPerm[RInv[metric_,indexlist_IndexList][rank_,case_,count_]]:=Module[{dummyInds,upperInds ,lowerInds,newcontracted},dummyinds=4Length[case]+Total[case]-Length[indexlist];
upperInds=IndexList@@Table[DummyIn[VBundleOfMetric[metric]],{i,1,dummyinds/2}];
newcontracted=Join[upperInds,Minus/@upperInds];

If[Length[indexlist]==4Length[case]+Total[case],RPerm[metric][{case,0},{rank},indexlist,toCycles[RInv[rank,case,count]/.DispatchRInvToPermRules[rank,case]]],RPerm[metric][{case,0},{rank},Join[indexlist,newcontracted],toCycles[RInv[rank,case,count]/.DispatchRInvToPermRules[rank,case]]]]
](*RPerm[metric][{case,0},{rank},Join[indexlist],toCycles[RInv[rank,case,count]/.DispatchRInvToPermRules[rank,case]]]*)*)


canon[metric_]:=Module[{upinds},upinds=DummyIn/@ConstantArray[VBundleOfMetric[metric],18];

IndexList@@Flatten@Transpose[{upinds,Minus/@upinds}]]
(*upindices[metric_]:=upindices[metric]=DummyIn/@ConstantArray[VBundleOfMetric[metric],18];

canon[metric_]:=IndexList@@Flatten@Transpose[{a=upindices[metric],Minus/@a}];*)


translate[(RPerm|WPerm)[metric_][{case_,dege_},{frees_},index_IndexList,perm_]]:=First@TranslatePerm[perm,{Images,4Length[case]+Plus@@case+4dege}];


RPerm[metric_][info_,frees_,indexlist_,-perm_]:=-RPerm[metric][info,frees,indexlist,perm];


WPerm[metric_][info_,frees_,indexlist_,-perm_]:=-WPerm[metric][info,frees,indexlist,perm];


riemannof[metric_,0,indices_,{other___,n_}]:=With[{CD=CovDOfMetric[metric]},Apply[Composition,CD/@indices[[Range[4+n,5,-1]]]][Apply[Riemann[CD],Take[indices,4]]]riemannof[metric,0,Drop[indices,4+n],{other}]];
riemannof[metric_,1,indices_,case_]:=riemannof[metric,0,Drop[indices,-4],case]Apply[epsilon[metric],Take[indices,-4]];
riemannof[_,_,{},{}]:=1;


PermToRiemann[rperm_]:=PermToRiemann[rperm,$CurvatureRelations];


PermToRiemann[rperm:RPerm[metric_][{case_,dege_},{0},free_IndexList,_],cr_]:=ToRicci[metric,cr,False][riemannof[metric,dege,List@@IndexSort[Join[free,canon[metric]]][[translate[rperm]]],Reverse[case]]];


PermToRiemann[rperm:RPerm[metric_][{case_,dege_},{rank_},free_IndexList,_],cr_]:=ToRicci[metric,cr,True][riemannof[metric,dege,List@@IndexSort[Join[free,canon[metric]]][[translate[rperm]]],Reverse[case]]];


PermToRiemann[wperm:WPerm[metric_][{case_,dege_},{0},free_IndexList,_],cr_]:=ToWeyl[ToRicci[metric,cr,False][riemannof[metric,dege,List@@IndexSort[Join[free,canon[metric]]][[translate[wperm]]],Reverse[case]]],CovDOfMetric[metric]];


PermToRiemann[wperm:WPerm[metric_][{case_,dege_},{rank_},free_IndexList,_],cr_]:=ToWeyl[ToRicci[metric,cr,True][riemannof[metric,dege,List@@IndexSort[Join[free,canon[metric]]][[translate[wperm]]],Reverse[case]]],CovDOfMetric[metric]];


(*To Ricci function needs to be written for free indices Here the thrid agrument is True if the expression is a tensor and False if it is a scalar*)


ToRicci[metric_,False,False][expr_]:=Scalar[expr];
ToRicci[metric_,False,True][expr_]:=expr;
ToRicci[metric_,True,False][expr_]:=Scalar@ContractMetric[expr/.CurvatureRelations[CovDOfMetric[metric],Riemann],metric]/.CurvatureRelations[CovDOfMetric[metric],Ricci];
ToWeyl[expr_,cd_]:=expr/.{Riemann[cd]:>Weyl[cd],Ricci[cd]:>TFRicci[cd]};
ToRicci[metric_,True,True][expr_]:=ContractMetric[expr/.CurvatureRelations[CovDOfMetric[metric],Riemann],metric]/.CurvatureRelations[CovDOfMetric[metric],Ricci];


InvToRiemann1[cr_][inv:(RInv|DualRInv|WInv|DualWInv)[_,_][_,_,_]]:=PermToRiemann[InvToPerm[inv],cr];


InvToRiemann[expr_]:=InvToRiemann[expr,$CurvatureRelations];


InvToRiemann[expr_,cr_]:=expr/.inv:(RInv|DualRInv|WInv|DualWInv)[_,_][_,_,_]:>InvToRiemann1[cr][inv];
SetNumberOfArguments[InvToRiemann,{1,2}];


(*No change for first three*)


addone[head_[n_Integer]]:=head[n+1];
addone[casePlus[{head_,n_Integer}]]:=casePlus[{head,n+1}];


SetAttributes[casePlus,{Flat,Orderless}]
casePlus[{head_,n__},c___,{head_,m__}]:=casePlus[{head,m,n},c];
casePlus[0,c___]:=casePlus[c];
casePlus[ERROR]:=ERROR;
casePlus[ERROR,__]:=ERROR;


degrees[expr_,cd_,metric_]:=With[{
riemann=Riemann[cd],
ricci=Ricci[cd],
ricciscalar=RicciScalar[cd],
weyl=Weyl[cd],
tfricci=TFRicci[cd],
eps=epsilon[metric]},
Module[{deg},
deg[cd[_][expr1_]x_.]:=casePlus[addone[deg[expr1]],deg[x]];
deg[_riemann x_.]:=casePlus[{Riemann,0},deg[x]];
deg[_ricci x_.]:=casePlus[{Ricci,0},deg[x]];
deg[_ricciscalar x_.]:=casePlus[{RicciScalar,0},deg[x]];
deg[_weyl x_.]:=casePlus[{Weyl,0},deg[x]];
deg[_tfricci x_.]:=casePlus[{TFRicci,0},deg[x]];
deg[_eps x_.]:=casePlus[{epsilon,0},deg[x]];
deg[1|-1]:=0;
deg[x_]:=Infinity;
deg[expr]
]
]


(*Added a metric times so that expression with g^ab can be passed through *)


RiemannToPerm[expr_,args___]:=RiemannToPerm0[ContractMetric@Expand[expr],args];
SetNumberOfArguments[RiemannToPerm,{1,2}];
(* Thread over sums *)
RiemannToPerm0[expr_Plus,args___]:=RiemannToPerm0[#,args]&/@expr;
RiemannToPerm0[expr_,args___]:=RiemannToPerm1[BreakInMonomials[BreakScalars@PutScalar[expr]],args];

(* Deal with the second argument *)
RiemannToPerm1[expr_]:=RiemannToPerm1[expr,$Metrics];
RiemannToPerm1[expr_,metrics_List]:=Fold[RiemannToPerm1,expr,metrics];
RiemannToPerm1[a_?NumberQ expr_,metric_]:=a RiemannToPerm1[expr,metric];
(*Look for scalars *)
RiemannToPerm1[Monomial[expr_],metric_Symbol]:=
arrange[expr,degrees[expr,CovDOfMetric[metric],metric],metric];
RiemannToPerm1[expr_Times,metric_]:=RiemannToPerm1[#,metric]&/@expr
(*RiemannToPerm1[Scalar[expr_],metric_Symbol]:=arrange[expr,degrees[expr,CovDOfMetric[metric],metric],metric];
RiemannToPerm1[expr_Times,metric_Symbol]:=RiemannToPerm2[ScalarTest[#,metric]&/@expr];
ScalarTest[expr_,metric_Symbol]:=If[ScalarQ[expr],RiemannToPerm1[expr,metric],expr]*)


RiemannToPerm1[Scalar[expr_],metric_Symbol]:=arrange[expr,degrees[expr,CovDOfMetric[metric],metric],metric];


RiemannToPerm1[Monomial[expr_],metric_Symbol]:=arrange[expr,degrees[expr,CovDOfMetric[metric],metric],metric];
RiemannToPerm1[Power[expr_,n_Integer],metric_Symbol]:=Power[RiemannToPerm1[expr,metric],n];
RiemannToPerm1[expr_,x_]:=expr;


RiemannToPerm1[tensor_Symbol[],metric_Symbol]:=RPerm[metric][{{0},0},{0},IndexList[],xAct`xPerm`Cycles[{2,3}]]/;tensor===RicciScalar[CovDOfMetric[metric]];


(* Possibilities for the first argument *)
(*RiemannToPerm2[a_?NumberQ expr_,metric_]:=a RiemannToPerm2[expr,metric];
RiemannToPerm2[expr_,metric_Symbol]:=HoldForm[arrange[expr,degrees[expr,CovDOfMetric[metric],metric],metric]];*)
(*RiemannToPerm1[metric[a_,b_]expr_,metric_Symbol]:=metric[a,b]RiemannToPerm1[expr,metric];*)


(* 0. Trivial cases *)
arrange[0,_,_]:=0;
arrange[expr_,Infinity,_]:=expr;
(* 1. There is Ricci or RicciScalar: convert to Riemann *)
HoldPattern[arrange[expr_,casePlus[{Ricci|RicciScalar,m__},c___],metric_]]:=arrange[RicciToRiemann[expr,CovDOfMetric[metric]],casePlus[{Riemann,m},c],metric];




(* 2a. There are only Riemanns: compute non-dual permutation *)

(*Change here: Get indicesof the expression and the rank of the tensor*)
HoldPattern[arrange[expr_,casePlus[{Riemann,Rcase__}],metric_]]:=With[{canonical={#[[1]],#[[2,1,1]],frees={Length[IndicesOf[Free][expr]]}}&@Reap[ToCanonical[expr],"NewIndices"]},arrange1[canonical,{Sort[{Rcase}],0},metric]];
(* 4. Final arrangements *)
HoldPattern[arrange[expr_,casePlus[{Riemann,Rcase__},{epsilon,0}],metric_]]:=With[{epsilonname=epsilon[metric]},Module[{result},
TagSet[epsilonname,xSortPrecedence[epsilonname],Infinity];
With[{canonical={#[[1]],#[[2,1,1]],frees={0}}&@Reap[ToCanonical[expr],"NewIndices"]},
result=arrange1[canonical,{Sort[{Rcase}],1},metric]
];
TagUnset[epsilonname,xSortPrecedence[epsilonname]];
result
]
];
(*Change here: Now arrange will have the indices of the expression. This will be*)

HoldPattern[arrange[expr_,casePlus[{Weyl,Rcase__}],metric_]]:=With[{canonical={#[[1]],#[[2,1,1]],frees={Length[IndicesOf[Free][expr]]}}&@Reap[ToCanonical[expr],"NewIndices"]},arrange1[canonical,{Sort[{Rcase}],0},metric]/.RPerm->WPerm];
(* 4. Final arrangements *)
HoldPattern[arrange[expr_,casePlus[{Weyl,Rcase__},{epsilon,0}],metric_]]:=With[{epsilonname=epsilon[metric]},Module[{result},
TagSet[epsilonname,xSortPrecedence[epsilonname],Infinity];
With[{canonical={#[[1]],#[[2,1,1]],frees={0}}&@Reap[ToCanonical[expr],"NewIndices"]},
result=arrange1[canonical,{Sort[{Rcase}],1},metric]/.RPerm->WPerm
];
TagUnset[epsilonname,xSortPrecedence[epsilonname]];
result
]
];


(* the list used to get the correct permutation *)


arrange1[0,_,_]:=0;
arrange1[{expr_,{sign_,perm_IndexList},frees_},degs:{_,_},metric_]:=RPerm[metric][degs,frees,IndicesOf[Free][expr],sign TranslatePerm[PermutationFromTo[List@@perm,List@@IndexSort[perm]],Cycles]]


FromWeyl[expr_,cd_]:=expr/.{Weyl[cd]:>Riemann[cd],TFRicci[cd]:>Ricci[cd]};


(*Need to adjust this see Riemann simplify for more details*)


RicciToRiemann[expr_,cd_]:=With[{ricciscalar=RicciScalar[cd],ricci=Ricci[cd],riemann=Riemann[cd],vbundle=First@VBundlesOfCovD[cd]},expr/.{
ricciscalar[]:>Module[{c=DummyIn@vbundle,d=DummyIn@vbundle},$RicciSign riemann[c,d,-c,-d]],ricci[a_,b_]:>Module[{c=DummyIn@vbundle},$RicciSign riemann[a,c,b,-c]]
}
];


(*Invariants will now have the indexlist of the expression this is stored in RInv[metric,indexlist] and is used so we can convert from invariant to perm as the permutation now depends on the sorted indexlist instead of a fixed list in Invar*)


PermToInv[RPerm[metric_][{case_List,0},{Rank_},indexlist_,perm_]]:=(perm/.DispatchPermToRInvRules[Rank,case])/.RInv->RInv[metric,indexlist];


PermToInv[RPerm[metric_][{case_List,1},{Rank_},indexlist_,perm_]]:=(perm/.DispatchPermToDualRInvRules[Rank,case])/.DualRInv->DualRInv[metric,indexlist];


PermToInv[WPerm[metric_][{case_List,0},{Rank_},indexlist_,perm_]]:=perm/.DispatchPermToRInvRules[Rank,case]/.RInv->WInv[metric,indexlist];


PermToInv[WPerm[metric_][{case_List,1},{Rank_},indexlist_,perm_]]:=perm/.DispatchPermToDualRInvRules[Rank,case]/.DualRInv->DualRInv[metric,indexlist];


PermToInv[expr_]:=expr/.perm:(RPerm|WPerm)[_][__]:>PermToInv[perm];
SetNumberOfArguments[PermToInv,1];


RiemannToInv[expr_]:=RiemannToInv[expr,$Metrics];


RiemannToInv[expr_,metrics_List]:=Fold[RiemannToInv,expr,metrics];


RiemannToInv[expr_,metric_Symbol?MetricQ]:=PermToInv[RiemannToPerm[expr,metric]];


RiemannToInv[expr_,x_]:=(Message[RiemannToInv::unknown,"metric or list of metrics",x];expr);
SetNumberOfArguments[RiemannToInv,{1,2}];


RiemannSimplify[expr_]:=RiemannSimplify[expr,$InvSimplifyLevel,$CurvatureRelations,$Metrics];


(*RiemannSimplify[expr_Plus]:=RiemannSimplify[#]&/@expr;*)


RiemannSimplify[expr_,step_Integer]:=RiemannSimplify[expr,step,$CurvatureRelations,$Metrics];


RiemannSimplify[expr_,cr:(True|False)]:=RiemannSimplify[expr,$InvSimplifyLevel,cr,$Metrics];


RiemannSimplify[expr_,metric:(_Symbol?MetricQ|{__Symbol?MetricQ})]:=RiemannSimplify[expr,$InvSimplifyLevel,$CurvatureRelations,metric];


RiemannSimplify[expr_,step_Integer,cr:(True|False),metric_]:=InvToRiemann[InvSimplify[RiemannToInv[expr,metric],step],cr];


SetNumberOfArguments[RiemannSimplify,{1,3}];


End[];
Protect["xAct`TInvar`*"];
Unprotect[xAct`TInvar`dim,xAct`TInvar`sigma,xAct`TInvar`$InvSimplifyLevel,xAct`TInvar`$CurvatureRelations,$ExpandedCommuteOrder12Q,xAct`TInvar`TInvarDirectory];
EndPackage[];
